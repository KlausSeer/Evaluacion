Para este caso, una solución óptima, sería hacer uso de object pooling, al momento de cargar la escena, creamos cierta cantidad de objetos y los mantenemos deshabilitados. A medida que vayamos necesitando spawnear dichos objetos, los vamos habilitando y poniendo en donde los necesitamos, de esta forma no instanciamos en Runtime a los enemigos y consumimos menos memoria en cada proceso.
Además, podemos aprovechar esto para reciclar a los enemigos y no destruirlos, solamente desactivarlos y volver a spawmnearlos una vez que nos quedemos sin objetos en el pool. De esta forma nos aseguramos de que hay un numero constante de enemigos en escena y no la sobrecargamos.
En caso no queramos reciclar enemigos por motivos de diseño, podemos deshabilitarlos y activar un marcador en ellos, para así correr una coroutine que se encargue de eliminarlos en cada frame de manera paralela y aligerar un poco la carga.
